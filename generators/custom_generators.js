Blockly.Arduino.extra_logic = function (block) {
    if (block.getFieldValue("OP") === "XOR") {
        return ["!" + (Blockly.Arduino.valueToCode(block, "A", Blockly.Arduino.ORDER_EQUALITY) || "false") + " != " + "!" + (Blockly.Arduino.valueToCode(block, "B", Blockly.Arduino.ORDER_EQUALITY) || "false"), Blockly.Arduino.ORDER_EQUALITY]
    } else {
        return ["!" + (Blockly.Arduino.valueToCode(block, "A", Blockly.Arduino.ORDER_EQUALITY) || "false") + " && " + "!" + (Blockly.Arduino.valueToCode(block, "B", Blockly.Arduino.ORDER_EQUALITY) || "false"), Blockly.Arduino.ORDER_EQUALITY]
    }
};
Blockly.Arduino.logic_ternary = function (a) { var b = Blockly.Arduino.valueToCode(a, "IF", Blockly.Arduino.ORDER_CONDITIONAL) || "false", c = Blockly.Arduino.valueToCode(a, "THEN", Blockly.Arduino.ORDER_CONDITIONAL) || "null"; a = Blockly.Arduino.valueToCode(a, "ELSE", Blockly.Arduino.ORDER_CONDITIONAL) || "null"; return [b + " ? " + c + " : " + a, Blockly.Arduino.ORDER_CONDITIONAL] };
// base.js
Blockly.Arduino.pulsein = function () {
    var code;
    var value_pin = Blockly.Arduino.valueToCode(this, 'pin', Blockly.Arduino.ORDER_ATOMIC) || '0';
    var value_timeout = Blockly.Arduino.valueToCode(this, 'timeout', Blockly.Arduino.ORDER_ATOMIC) || '-1';
    var dropdown_type = (this.getFieldValue('type') == 'HIGH') ? 'HIGH' : 'LOW';
    console.log(value_timeout);
    if (value_timeout > 0) {
        code = 'pulseIn(' + value_pin + ', ' + dropdown_type + ', ' + value_timeout + ')';
    } else {
        code = 'pulseIn(' + value_pin + ', ' + dropdown_type + ')';
    }
    // TODO: Change ORDER_NONE to the correct strength.
    Blockly.Arduino.setups_['setup_output_' + value_pin] = 'pinMode(' + value_pin + ', INPUT);';
    return [code, Blockly.Arduino.ORDER_ATOMIC];
};
Blockly.Arduino.SSD1306_clear = function () {
    Blockly.Arduino.definitions_.define_Tiny4K = "#include <Wire.h>\n#define TINY4KOLED_QUICK_BEGIN\n#include <Tiny4kOLED.h>\n";
    Blockly.Arduino.setups_.setup_SSD1306 = "oled.begin();\n"

    return "oled.clear();\n"
}

Blockly.Arduino.SSD1306_print = function (block) {
    Blockly.Arduino.definitions_.define_Tiny4K = "#include <Wire.h>\n#define TINY4KOLED_QUICK_BEGIN\n#include <Tiny4kOLED.h>\n";
    Blockly.Arduino.setups_.setup_SSD1306 = "oled.begin();\n"

    let contentCode = Blockly.Arduino.valueToCode(block, "CONTENT", Blockly.Arduino.ORDER_ATOMIC)

    return "oled.print(" + contentCode + ");\n"
}

Blockly.Arduino.SSD1306_font = function (block) {
    Blockly.Arduino.definitions_.define_Tiny4K = "#include <Wire.h>\n#define TINY4KOLED_QUICK_BEGIN\n#include <Tiny4kOLED.h>\n";
    Blockly.Arduino.setups_.setup_SSD1306 = "oled.begin();\n"

    // this lookup was generated by manually copying the array names, automatically listing the files available
    // in the fonts library, and matching them. discrepancies may be due to human error. -laggycomputer
    font_to_include_map = {
        "FONT5X5": "5x5_font.h",
        "FONT7LINEDIGITAL": "7linedigital_font.h",
        "FONTACME5OUTLINES": "acme_5_outlines_font.h",
        "FONTAZTECH": "aztech_font.h",
        "FONTBLOKUS": "Blokus_font.h",
        "FONTBMPLAIN": "BMplain_font.h",
        "FONTBMSPA": "BMSPA_font.h",
        "&cp_437_box_drawing_font": "boxyfont.h",
        "FONTBUBBLESSTANDARD": "bubblesstandard_font.h",
        "FONTCOMMOMONOSPACED": "Commo-Monospaced_font.h",
        "FONTCRACKERS": "crackers_font.h",
        "FONT8X16ATARI": "font8x16atari.h",
        "FONT11X16": "font11x16.h",
        "&ssd1306xled_font16x16cn": "font16x16cn.h",
        "FONT16X32DIGITS": "font16x32digits.h",
        "FONTFORMPLEX12": "formplex12_font.h",
        "FONTHAIKU": "haiku_font.h",
        "FONTHISKYF21": "HISKYF21_font.h",
        "FONTHOMESPUN": "homespun_font.h",
        "FONTHUNTER": "HUNTER_font.h",
        "FONTM38": "m38_font.h",
        "FONTMINIMUM": "Minimum_font.h",
        "FONTMINIMUM1": "Minimum+1_font.h",
        "FONT8X16MDOS": "ModernDos.h",
        "FONT8X8MDOS": "ModernDos8.h",
        "FONT8X16PO": "PixelOperator.h",
        "FONT8X16POB": "PixelOperatorBold.h",
        "FONTPZIM3X5": "pzim3x5_font.h",
        "FONTRAUMSOND": "Raumsond_font.h",
        "FONTRENEW": "renew_font.h",
        "FONTSLOTH": "sloth_font.h",
        "FONTSUPERDIG": "SUPERDIG_font.h",
        "FONTTAMAMINI02": "tama_mini02_font.h",
        "FONTZXPIX": "zxpix_font.h"
    }

    let font = block.getFieldValue("FONT")

    let resolved_include;
    // is the font built-in? if not, import the fonts too:
    if (!["FONT8X16", "FONT6X8"].includes(font)) {
        resolved_include = font_to_include_map[font];
    }

    Blockly.Arduino.definitions_["define_" + font] = "#include <" + resolved_include + ">\n"

    return [font, Blockly.Arduino.ORDER_ATOMIC]
}
